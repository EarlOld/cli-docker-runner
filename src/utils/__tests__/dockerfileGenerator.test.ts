import { DockerfileGenerator } from '../dockerfileGenerator';
import * as fs from 'fs';
import * as path from 'path';

jest.mock('fs');
jest.mock('path');

describe('DockerfileGenerator', () => {
  let generator: DockerfileGenerator;

  beforeEach(() => {
    generator = new DockerfileGenerator();
    jest.clearAllMocks();
  });

  describe('generateDockerfile', () => {
    it('should generate Dockerfile with specified node version', () => {
      const result = generator.generateDockerfile('18');

      expect(result).toContain('FROM node:18-alpine');
      expect(result).toContain('WORKDIR /app');
      expect(result).toContain('COPY package*.json ./');
      expect(result).toContain('RUN npm ci --omit=dev || npm install --production');
      expect(result).toContain('COPY . .');
      expect(result).toContain('EXPOSE 3000');
      expect(result).toContain('CMD ["npm", "start"]');
    });

    it('should generate Dockerfile with custom work directory', () => {
      const result = generator.generateDockerfile('20', '/custom/workdir');

      expect(result).toContain('WORKDIR /custom/workdir');
    });

    it('should include security comment', () => {
      const result = generator.generateDockerfile('20');

      expect(result).toContain('# Generated by cli-docker-runner');
    });
  });

  describe('saveDockerfile', () => {
    it('should save Dockerfile to specified directory', () => {
      const content = 'FROM node:20-alpine';
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/Dockerfile.tmp');

      const result = generator.saveDockerfile(content, targetDir);

      expect(fs.writeFileSync).toHaveBeenCalledWith('/mock/project/Dockerfile.tmp', content);
      expect(result).toBe('/mock/project/Dockerfile.tmp');
    });
  });

  describe('generateDockerIgnore', () => {
    it('should generate proper .dockerignore content', () => {
      const result = generator.generateDockerIgnore();

      expect(result).toContain('node_modules');
      expect(result).toContain('.env');
      expect(result).toContain('.git');
      expect(result).toContain('Dockerfile.tmp');
      expect(result).toContain('coverage');
    });
  });

  describe('saveDockerIgnore', () => {
    it('should create .dockerignore if it does not exist', () => {
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/.dockerignore');
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      generator.saveDockerIgnore(targetDir);

      expect(fs.writeFileSync).toHaveBeenCalled();
    });

    it('should not overwrite existing .dockerignore', () => {
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/.dockerignore');
      (fs.existsSync as jest.Mock).mockReturnValue(true);

      generator.saveDockerIgnore(targetDir);

      expect(fs.writeFileSync).not.toHaveBeenCalled();
    });
  });
});
