import { DockerfileGenerator } from '../dockerfileGenerator';
import * as fs from 'fs';
import * as path from 'path';

jest.mock('fs');
jest.mock('path');

describe('DockerfileGenerator', () => {
  let generator: DockerfileGenerator;

  beforeEach(() => {
    generator = new DockerfileGenerator();
    jest.clearAllMocks();
  });

  describe('generateDockerfile', () => {
    it('should generate Dockerfile with specified node version', () => {
      const result = generator.generateDockerfile('18');

      expect(result).toContain('FROM node:18-alpine');
      expect(result).toContain('WORKDIR /app');
      expect(result).toContain('COPY package*.json ./');
      expect(result).toContain('COPY .npmrc* ./');
      expect(result).toContain('RUN npm install');
      expect(result).toContain('COPY . .');
      expect(result).toContain('EXPOSE 3000');
      expect(result).toContain('CMD ["npm", "start"]');
    });

    it('should install all dependencies including dev', () => {
      const result = generator.generateDockerfile('20');

      expect(result).toContain('RUN npm install');
      expect(result).not.toContain('--omit=dev');
      expect(result).not.toContain('--production');
    });

    it('should generate Dockerfile with custom work directory', () => {
      const result = generator.generateDockerfile('20', '/custom/workdir');

      expect(result).toContain('WORKDIR /custom/workdir');
    });

    it('should include security comment', () => {
      const result = generator.generateDockerfile('20');

      expect(result).toContain('# Generated by cli-docker-runner');
    });

    it('should not generate undefined in FROM statement', () => {
      const result = generator.generateDockerfile('20');

      expect(result).not.toContain('FROM node:undefined');
      expect(result).not.toContain('node:undefined-alpine');
      expect(result).toMatch(/FROM node:\d+-alpine/);
    });

    it('should handle various node versions correctly', () => {
      const versions = ['16', '18', '20', '21'];
      
      versions.forEach(version => {
        const result = generator.generateDockerfile(version);
        expect(result).toContain(`FROM node:${version}-alpine`);
        expect(result).not.toContain('undefined');
      });
    });

    it('should use default node version when undefined and throw error for empty string', () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const dockerfile = generator.generateDockerfile(undefined as any);
      expect(dockerfile).toContain('FROM node:22-alpine');
      expect(() => generator.generateDockerfile('')).toThrow('Node.js version is required and cannot be empty');
    });

    it('should include conditional nodemon installation when needed', () => {
      const result = generator.generateDockerfile('18', '/app', true);
      
      expect(result).toContain('# Install nodemon globally for live reload');
      expect(result).toContain('RUN npm install -g nodemon');
    });

    it('should skip nodemon installation when not needed', () => {
      const result = generator.generateDockerfile('20', '/app', false);
      
      expect(result).not.toContain('# Install nodemon globally for live reload');
      expect(result).not.toContain('RUN npm install -g nodemon');
    });

    it('should include Rollup platform-specific packages installation', () => {
      const result = generator.generateDockerfile('20', '/app', false);

      expect(result).toContain('# Install additional Rollup platform-specific packages if needed');
      expect(result).toContain("grep -q '\"rollup\"' package.json || grep -q '\"vite\"' package.json");
      expect(result).toContain('@rollup/rollup-linux-arm64-musl');
      expect(result).toContain('@rollup/rollup-linux-x64-musl');
      expect(result).toContain('@rollup/rollup-linux-arm64-gnu');
      expect(result).toContain('@rollup/rollup-linux-x64-gnu');
      expect(result).toContain('@rollup/rollup-darwin-arm64');
      expect(result).toContain('@rollup/rollup-darwin-x64');
    });

    it('should handle Rollup installation failures gracefully', () => {
      const result = generator.generateDockerfile('18', '/app', true);

      expect(result).toContain('2>/dev/null || echo "âš ï¸  Some Rollup packages could not be installed (this is normal)"');
    });

    it('should include PATH configuration for node_modules/.bin', () => {
      const result = generator.generateDockerfile('20', '/app', false);

      expect(result).toContain('ENV PATH="/app/node_modules/.bin:$PATH"');
    });

    it('should handle custom work directory in PATH configuration', () => {
      const result = generator.generateDockerfile('18', '/custom/path', true);

      expect(result).toContain('ENV PATH="/custom/path/node_modules/.bin:$PATH"');
    });

    it('should detect rollup, vite, and astro patterns', () => {
      const result = generator.generateDockerfile('20', '/app', false);

      // Should check for "rollup", "vite", and "astro" in package.json
      expect(result).toContain("grep -q '\"rollup\"' package.json || grep -q '\"vite\"' package.json || grep -q '\"astro\"' package.json");
      expect(result).toContain('ðŸ”§ Detected Rollup/Vite/Astro project, installing platform-specific packages...');
    });
  });

  describe('saveDockerfile', () => {
    it('should save Dockerfile to specified directory', () => {
      const content = 'FROM node:20-alpine';
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/Dockerfile.tmp');

      const result = generator.saveDockerfile(content, targetDir);

      expect(fs.writeFileSync).toHaveBeenCalledWith('/mock/project/Dockerfile.tmp', content);
      expect(result).toBe('/mock/project/Dockerfile.tmp');
    });
  });

  describe('generateDockerIgnore', () => {
    it('should generate proper .dockerignore content', () => {
      const result = generator.generateDockerIgnore();

      expect(result).toContain('node_modules');
      expect(result).toContain('.env');
      expect(result).toContain('.git');
      expect(result).toContain('Dockerfile.tmp');
      expect(result).toContain('coverage');
    });
  });

  describe('saveDockerIgnore', () => {
    it('should create .dockerignore if it does not exist', () => {
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/.dockerignore');
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      generator.saveDockerIgnore(targetDir);

      expect(fs.writeFileSync).toHaveBeenCalled();
    });

    it('should not overwrite existing .dockerignore', () => {
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/.dockerignore');
      (fs.existsSync as jest.Mock).mockReturnValue(true);

      generator.saveDockerIgnore(targetDir);

      expect(fs.writeFileSync).not.toHaveBeenCalled();
    });

    it('should include .npmrc copy instruction for npm configuration', () => {
      const result = generator.generateDockerfile('18');

      expect(result).toContain('COPY package*.json ./');
      expect(result).toContain('COPY .npmrc* ./');
      // Ensure .npmrc is copied before npm install
      const packageCopyIndex = result.indexOf('COPY package*.json ./');
      const npmrcCopyIndex = result.indexOf('COPY .npmrc* ./');
      const npmInstallIndex = result.indexOf('# Install all dependencies (including dev)\nRUN npm install');
      
      expect(packageCopyIndex).toBeGreaterThan(-1);
      expect(npmrcCopyIndex).toBeGreaterThan(-1);
      expect(npmInstallIndex).toBeGreaterThan(-1);
      expect(npmrcCopyIndex).toBeGreaterThan(packageCopyIndex);
      expect(npmInstallIndex).toBeGreaterThan(npmrcCopyIndex);
    });
  });
});
