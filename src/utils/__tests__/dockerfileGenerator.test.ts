import { DockerfileGenerator } from '../dockerfileGenerator';
import * as fs from 'fs';
import * as path from 'path';

jest.mock('fs');
jest.mock('path');

describe('DockerfileGenerator', () => {
  let generator: DockerfileGenerator;

  beforeEach(() => {
    generator = new DockerfileGenerator();
    jest.clearAllMocks();
  });

  describe('generateDockerfile', () => {
    it('should generate Dockerfile with specified node version', () => {
      const result = generator.generateDockerfile('18');

      expect(result).toContain('FROM node:18-alpine');
      expect(result).toContain('WORKDIR /app');
      expect(result).toContain('COPY package*.json ./');
      expect(result).toContain('RUN npm ci || npm install');
      expect(result).toContain('COPY . .');
      expect(result).toContain('EXPOSE 3000');
      expect(result).toContain('CMD ["npm", "start"]');
    });

    it('should install all dependencies including dev', () => {
      const result = generator.generateDockerfile('20');

      expect(result).toContain('RUN npm ci || npm install');
      expect(result).not.toContain('--omit=dev');
      expect(result).not.toContain('--production');
    });

    it('should generate Dockerfile with custom work directory', () => {
      const result = generator.generateDockerfile('20', '/custom/workdir');

      expect(result).toContain('WORKDIR /custom/workdir');
    });

    it('should include security comment', () => {
      const result = generator.generateDockerfile('20');

      expect(result).toContain('# Generated by cli-docker-runner');
    });

    it('should not generate undefined in FROM statement', () => {
      const result = generator.generateDockerfile('20');

      expect(result).not.toContain('FROM node:undefined');
      expect(result).not.toContain('node:undefined-alpine');
      expect(result).toMatch(/FROM node:\d+-alpine/);
    });

    it('should handle various node versions correctly', () => {
      const versions = ['16', '18', '20', '21'];
      
      versions.forEach(version => {
        const result = generator.generateDockerfile(version);
        expect(result).toContain(`FROM node:${version}-alpine`);
        expect(result).not.toContain('undefined');
      });
    });

    it('should throw error if nodeVersion is undefined or empty', () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      expect(() => generator.generateDockerfile(undefined as any)).toThrow('Node.js version is required and cannot be empty');
      expect(() => generator.generateDockerfile('')).toThrow('Node.js version is required and cannot be empty');
    });
  });

  describe('saveDockerfile', () => {
    it('should save Dockerfile to specified directory', () => {
      const content = 'FROM node:20-alpine';
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/Dockerfile.tmp');

      const result = generator.saveDockerfile(content, targetDir);

      expect(fs.writeFileSync).toHaveBeenCalledWith('/mock/project/Dockerfile.tmp', content);
      expect(result).toBe('/mock/project/Dockerfile.tmp');
    });
  });

  describe('generateDockerIgnore', () => {
    it('should generate proper .dockerignore content', () => {
      const result = generator.generateDockerIgnore();

      expect(result).toContain('node_modules');
      expect(result).toContain('.env');
      expect(result).toContain('.git');
      expect(result).toContain('Dockerfile.tmp');
      expect(result).toContain('coverage');
    });
  });

  describe('saveDockerIgnore', () => {
    it('should create .dockerignore if it does not exist', () => {
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/.dockerignore');
      (fs.existsSync as jest.Mock).mockReturnValue(false);

      generator.saveDockerIgnore(targetDir);

      expect(fs.writeFileSync).toHaveBeenCalled();
    });

    it('should not overwrite existing .dockerignore', () => {
      const targetDir = '/mock/project';

      (path.join as jest.Mock).mockReturnValue('/mock/project/.dockerignore');
      (fs.existsSync as jest.Mock).mockReturnValue(true);

      generator.saveDockerIgnore(targetDir);

      expect(fs.writeFileSync).not.toHaveBeenCalled();
    });
  });
});
